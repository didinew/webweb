
⸻

🗓️ Day 6：USER_STREAM 实时成交 / 余额监听

你今天要搞懂并做到：
	•	USER_STREAM 是什么、解决什么问题
	•	成交 / 余额 / 订单事件的真实顺序
	•	用 Node.js + WebSocket 实时监听账户变化
	•	理解 为什么这是量化 / 高频的基础

⸻

一、USER_STREAM 是什么？（一句话）

USER_STREAM = 交易所主动把你的账户事件“推”给你

不再是：
你问交易所：现在咋样？

而是：
交易所告诉你：刚刚发生了什么


⸻

二、为什么一定要用 USER_STREAM？

如果你只用 REST：
	•	❌ 轮询慢
	•	❌ 成交会延迟
	•	❌ 高频直接没法做

USER_STREAM：
	•	✅ 毫秒级
	•	✅ 成交即达
	•	✅ 余额同步

📌 真实交易系统 = REST + WS

⸻

三、USER_STREAM 能收到什么？

核心三类（你必须认识）：

1️⃣ ORDER_UPDATE（订单状态）
open → partially_filled → filled → canceled

2️⃣ TRADE_UPDATE（真实成交）
成交价 / 数量 / 手续费

3️⃣ BALANCE_UPDATE（余额变化）
free / used / total

四、完整流程图（非常重要）
你下单
  ↓
订单进入撮合
  ↓
成交发生
  ↓
推送 TRADE_UPDATE
  ↓
推送 BALANCE_UPDATE
  ↓
订单状态更新

⚠️ 顺序不保证严格一致
👉 必须做幂等处理（后面会讲）


⸻

五、实战：Node.js 监听 USER_STREAM（Binance Sandbox）

1️⃣ 获取 listenKey

import axios from 'axios'

const res = await axios.post(
  'https://testnet.binance.vision/api/v3/userDataStream',
  null,
  {
    headers: { 'X-MBX-APIKEY': process.env.API_KEY },
  }
)

const listenKey = res.data.listenKey

2️⃣ 建立 WebSocket
import WebSocket from 'ws'

const ws = new WebSocket(
  `wss://testnet.binance.vision/ws/${listenKey}`
)

ws.on('message', (msg) => {
  const data = JSON.parse(msg)
  console.log(data.e, data)
})


⸻

六、你会看到的核心事件（重点）

1️⃣ 成交事件（executionReport）

{
  "e": "executionReport",
  "X": "PARTIALLY_FILLED",
  "L": "30100",
  "l": "0.01",
  "n": "0.00001",
  "N": "BTC"
}

字段
含义
X
订单当前状态
L
本次成交价
l
本次成交量
n
手续费
N
手续费资产

2️⃣ 余额更新事件（outboundAccountPosition）

{
  "e": "outboundAccountPosition",
  "B": [
    {
      "a": "USDT",
      "f": "1000",
      "l": "0"
    }
  ]
}
📌 f = free，l = locked


⸻

七、专业级处理方式（你要记住）

❌ 错误方式
收到事件 → 直接改余额

✅ 正确方式
收到事件
→ 按 orderId / tradeId 更新
→ 可重复、可回放

这就是 事件驱动架构


⸻

八、为什么 USER_STREAM 是量化的命根子？

因为：
	•	策略依赖成交回报
	•	风控依赖余额变化
	•	延迟 = 亏钱

📌 没有 WS，就没有量化


