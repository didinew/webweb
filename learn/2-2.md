Day 2｜助记词 & HD Wallet（深度实操 + 推导）

核心一句话：
助记词不是私钥，而是私钥工厂的种子。

⸻

一、助记词到底是什么？（先把误解清空）

❌ 常见误解
	•	助记词 = 私钥
	•	一个地址 = 一个助记词
	•	换地址就换身份

✅ 正确认知
助记词 → Seed → 主私钥 → 无限子私钥

二、BIP39：助记词生成原理（推导级）

1️⃣ 熵（Entropy）
	•	128 bit → 12 词
	•	256 bit → 24 词

128 bits 随机数
+ 4 bits 校验和
= 132 bits
÷ 11 bits
= 12 words

👉 每个单词来自一个 2048 词表（2¹¹）

⸻

2️⃣ 助记词不是安全的“文字”
	•	本质是 二进制熵的编码
	•	换语言 ≠ 换私钥（中英日词表都一样）

⸻

三、Seed 是真正的“核武器”

生成公式（重要）

Seed = PBKDF2(
  mnemonic,
  "mnemonic" + passphrase,
  2048 次
)

	•	passphrase = 助记词的“密码”
	•	钱包很少用（但非常高级）

👉 同一助记词 + 不同 passphrase = 完全不同世界


⸻

四、HD Wallet（层级确定性钱包）原理

为什么要 HD Wallet？
	•	一个 seed
	•	无限地址
	•	可恢复
	•	不用存每个私钥

⸻

树形结构（非常重要）
Seed
 └─ Master Key (m)
     ├─ m/44'/60'/0'/0/0
     ├─ m/44'/60'/0'/0/1
     ├─ m/44'/60'/0'/0/2

👉 所有地址都可以 确定性重建

⸻

五、路径推导（BIP44 彻底拆）
m / purpose / coin_type / account / change / index

字段
含义
44’
BIP44
60’
Ethereum
0’
主账户
0
外部地址
n
第 n 个地址

📌 ' = hardened（强化推导）

六、Node.js 实操（重点来了）

我们用 ethers v6

1️⃣ 从助记词生成钱包
import { HDNodeWallet } from 'ethers'

const mnemonic = 'test test test test test test test test test test test junk'

const wallet = HDNodeWallet.fromPhrase(mnemonic)

console.log(wallet.address)
console.log(wallet.path)

2️⃣ 推导多个地址（核心）

for (let i = 0; i < 3; i++) {
  const child = wallet.derivePath(`m/44'/60'/0'/0/${i}`)
  console.log(i, child.address)
}

👉 重点理解
	•	顺序确定
	•	永远一致
	•	不需要存储

⸻

3️⃣ 验证“地址可重建”

const walletA = HDNodeWallet.fromPhrase(mnemonic).derivePath("m/44'/60'/0'/0/5")
const walletB = HDNodeWallet.fromPhrase(mnemonic).derivePath("m/44'/60'/0'/0/5")

console.log(walletA.address === walletB.address) // true


⸻

七、工程级安全认知（面试杀器）

为什么前端不能碰助记词？
	•	XSS
	•	插件注入
	•	浏览器内存不可控

为什么钱包能“无限换地址”？
	•	地址 = index
	•	身份 = seed


⸻

八、助记词 vs 私钥 vs 地址（终极对照表）

项目
能否恢复
是否唯一
丢失后果
地址
❌
❌
可查不可控
私钥
❌
✅
永久丢失
助记词
✅
✅
全部资产归零

👉 助记词 = 主钥匙

九、面试标准回答（直接背）

Q：为什么 12 个词可以生成无限地址？

标准回答：

助记词通过 BIP39 生成 seed，
再通过 BIP32/44 的确定性推导算法，
可以按路径派生无限私钥，
所有地址都可以从同一个 seed 复现。

⸻

十、你今天必须彻底想通的 3 件事

1️⃣ 助记词是 私钥生成器，不是私钥
2️⃣ 钱包不是存地址，而是存 seed
3️⃣ 所有地址都可以被“重新算出来”

